---
title: 【Python 高级特性】装饰器：给函数穿上外套，扩展功能
date: 2024-2-15 12:00 +0800
categories: [Python 高级特性]
tags: [Python, 装饰器]
---

Hi 朋友们，我会用一系列文章展示 Python 高级特性，这篇文章是系列的第三篇。

这篇文章会介绍 Python 中的装饰器，你可以将装饰器理解为函数的外套，它可以让我们在不修改原有函数的情况下，对函数的功能进行扩展。

我会在这篇文章中介绍如何创建装饰器，和装饰器的用法。

# 装饰器的原理：将函数作为对象

Python 是一门面向对象的语言，也就是说，万物皆对象。函数也是对象，所以我们可以将函数作为参数传递给另一个函数。下面的代码展示了这个原理：

```python
def plus(x, y):
    return x + y

def operate(func, x, y):
    return func(x, y)

result = operate(plus, 2, 3)
```

函数 `operate` 接受的第一个参数需要是函数对象，我们将函数 `plus` 作为参数传递给 `operate`，然后在 `operate` 中调用 `add`。

通过上面这个例子，相信你已经可以理解函数是对象的意思了。

# 创建装饰器

## 装饰器的本质

装饰器本质上是一个函数，它接受一个函数作为原函数，然后返回一个新函数。新函数往往会对原函数进行一些功能上的扩展。

下面是一个简单的装饰器。

```python
def decorator(func):
    def wrapper(*args,**kwargs):
        print(f'{func.__name__} is running')
        result = func(*args,**kwargs)
        return result
    return wrapper
```

装饰器 `decorator` 接受原函数 `func` 后，在自己内部定义了新函数 `wrapper`，并返回 `wrapper`。

`wrapper` 的功能很简单，做了三件事：打印原函数名称、调用原函数并存储运行结果、返回原函数的运行结果。

这个装饰器非常简单，但它很好地揭示了装饰器的本质。

## wrapper 的参数

定义 `wrapper` 时候需要注意，因为 `wrapper` 是用来代替原函数的，所以它需要接受和原函数一样的参数。而如果我们希望这个装饰器可以装饰任意函数，那么 `wrapper` 就需要接受任意参数。所以我们使用了 `*args` 和 `**kwargs` 来接受任意参数。

## wrapper 的属性

装饰器返回的 `wrapper` 会丢掉原函数的**元信息**，比如 `docstring` `__name__` 等等。以上文的 `now` 为例，如果这个时候通过 `now.__name__` 来查看函数名称，返回的会是 `'wrapper'` ，因为装饰器中返回的确是 `wrapper`。

所以在装饰器中，需要把原函数的**元信息拷贝**到 `wrapper` 中。通过模组 `functools.wraps` 可以直接完成。

```python
import functools

def decorator(func):
    @functools.wraps(func)
    def wrapper(*args,**kwargs):
        print(f'{func.__name__} is running')
        result = func(*args,**kwargs)
        return result
    return wrapper
```

> `@functools.wraps(func)` 也是一个装饰器， `func` 作为传入的参数定义了这个装饰器，装饰接下来定义的 `wrapper`，让 `wrapper` 拥有 `func` 的所有属性。如果使用参数定义装饰器这个话让你有点晕，没关系，这个概念在下面会有更详细的解释。

# 使用装饰器

## 基本使用

定义好装饰器后，我可以定义一个新的函数来作为装饰后的函数。

```python
def plus(a,b):
	return a+b

decorated_plus = decorator(plus)
```

`decorated_plus` 就是 `plus` 被装饰后的函数。现在调用 `decorated_plus` 时，会先打印 `do something before func`，然后执行 `plus`，最后打印 `do something after func`。

差不多的功能用两个变量名未免太浪费，更何况原本的 `plus` 不会再被使用。所以可以更直接一点，用函数原来的名字定义。

```python
plus = decorator(plus)
```

实际上，Python 提供了一个更简单的语法糖来使用装饰器，就是在函数定义前加上 `@decorator`。

```python
@decorator
def plus(a,b):
	return a+b
```

使用 `@decorator` 语法糖完全等价于使用原名定义装饰后的函数。

## 需要接受参数的装饰器

截至目前我们看到的装饰器都很简单，只需要打印原函数的名字。想象稍微更复杂一点的情况，比如有的函数需要打印时间，有的函数不需要。

这种情况下，我们需要定义一个**定义装饰器**的函数，这个函数会根据参数返回不同的装饰器。听起来有点绕，但让我们看例子，你很快就会理解。

```python
def log(enable_time_print=False):
    def decorator(func):
        def wrapper(*args, **kw):
            if enable_time_print:
                print(f'{func.__name__} is running at {datetime.datetime.now()}')
            else:
                print(f'{func.__name__} is running')
            return func(*args, **kw)
        return wrapper
    return decorator
```

`log` 是一个定义装饰器的函数，它接受一个参数 `enable_time_print`，然后返回一个装饰器。这个装饰器会根据 `enable_time_print` 定义不同的 `wrapper`。

通过 `log`，我们可以定义不同的装饰器，`log(enable_time_print=True)` 和 `log(enable_time_print=False)` 会返回两个不同的装饰器。

下面是一个例子。

```python
@log(enable_time_print=True)
def plus(a,b):
    return a+b
```

上面的语句等价于 `plus = log(enable_time_print=True)(plus)`。

# 最后

这篇文章我们介绍了装饰器的本质，以及如何使用装饰器。希望你读完后能对装饰器有一个清晰的认识，并应用在实际的代码中。

如果你还有其他的问题，欢迎在评论区留言，我会尽快回复。

如果你觉得这篇文章对你有帮助，欢迎点赞分享。也欢迎关注我的频道，我会持续更新 Python 相关的内容。感谢你的阅读。
