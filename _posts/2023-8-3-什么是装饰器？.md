---
title: 什么是装饰器？
date: 2023-8-3 21:00:00 +0800
categories: [技术]
tags: [Python]
pin: false
toc: true
---

有这样一个函数：

```python
def foo():
	print('foo')
```

现在有一个新的需求，想要在使用这个函数前，打印时间。比较容易想到的方法当然是改写函数：

```python
def foo():
	print('time')
	print('foo')
```

但如果多个函数都需要打印时间，这样添加就太麻烦了。于是想到，函数也是一个对象，我可以通过把函数传入传出，来达到定义新函数的目的：

```python
def printtime(func):
	print(time)
	func()
```

这就是装饰器的基本思路。

## 装饰器的作用

如果能有什么方法将`foo`包裹起来，添加完需要的功能，然后返回一个新的`foo`函数就好了。

总结一下，我们希望有这样一个东西，**传入一个函数，然后返回一个带着新功能的新函数**。

由此，写出了这个函数：

```python
def decorator(func_to_decorate):
	def wrap_func():
		print('time')
		func_to_decorate()
	return wrap_func
```

这就是一个装饰器，通过这样：

```python
foo = decorator(foo)
```

创建了一个新的foo函数，再次执行这个函数可以返回我们需要的：

```python
foo()
# time foo
```

## 通过 @ 使用装饰器

通过这句话，我们定义一个新的、被装饰的函数。

```python
foo_decorated = decorator(foo)
```

但是如果多个函数都这样定义一遍，也比较麻烦。通过在定义函数前使用 **`@`** ，可以轻松许多。

```python
@decorator
def foo():
    print("foo")
```

这样子，相当于执行了语句

```python
foo = decorator(foo)
```

就不需要再另外定义一个函数，直接使用`foo()` 就能得到想要的结果。

## 如果装饰器也需要传入参数

比如有的装饰器要在函数前加 `text1` ，有的需要加 `text2` ，那就不能共用一个装饰器了。但难道我们就要分别定义两个只有参数不同功能完全相同的装饰器吗，no no no。

我们可以定义一个**定义装饰器**的函数，就像这样：

```python
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(f'{text} {func.__name__}')
            return func(*args, **kw)
        return wrapper
    return decorator
```

使用这个函数，比如 `log('execute')` ，就可以定义一个装饰器了。

那么用法就是这样

```python
@log('execute')
def now():
    print('2015-3-25')
```

这个 `@log('execute')` 就相当于

```python
now = log('execute')(now)
```

## wrapper 的属性

装饰器返回的 `wrapper` 会丢掉原函数的**元信息**，比如 `docstring` `__name__` 等等。以上文的 `now` 为例，如果这个时候通过 `now.__name__` 来查看函数名称，返回的会是 `'wrapper'` ，因为装饰器中返回的确是 `wrapper`。

所以在装饰器中，需要把原函数的**元信息拷贝**到 `wrapper` 中。通过模组`functools.wraps` 可以直接完成。

```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

`@functools.wraps(func)` 也是一个装饰器， `func` 作为传入的参数定义了这个装饰器，装饰接下来定义的`wrapper`，让`wrapper`拥有`func`的所有属性。

## 对类使用装饰器

当想改变一个类的某个属性或者函数，又不想使用继承因为确实蛮麻烦的，别忘了，**装饰器同样可以作用在类上**。

让我们回忆一下装饰器的输入与返回，输入一个函数，返回一个函数。

对于类来说也是同样的道理，输入一个类，返回一个类。

下面是一个例子。

```python
def log_getattribute(cls):
    # Get the original implementation
    orig_getattribute = cls.__getattribute__

    # Make a new definition
    def new_getattribute(self, name):
        print('getting:', name)
        return orig_getattribute(self, name)

    # Attach to the class and return
    cls.__getattribute__ = new_getattribute
    return cls

# Example use
@log_getattribute
class A:
    def __init__(self,x):
        self.x = x
    def spam(self):
        pass
```